
=== IntegrationTester Agent Log ===
Timestamp: 2025-08-16T16:13:18.224923
Task: Integration test for: Database Schema for Raw Data

Output:
import unittest
import sqlite3
import os
import tempfile
import io
import contextlib

# The implementation from '1.2.1.3.2' is included here to make the test self-contained.
# In a real project, this would be `from your_module import run_migrations`.

def run_migrations(db_path, migrations_dir):
    """
    Applies database migrations from a specified directory to an SQLite database.

    This function connects to an SQLite database, checks for a `schema_migrations`
    table to track applied migrations, and applies any new, unapplied SQL migration
    files found in the given directory. Migrations are applied in alphabetical order
    of their filenames.

    Args:
        db_path (str): The path to the SQLite database file.
        migrations_dir (str): The path to the directory containing .sql migration files.
    """
    conn = None
    try:
        # Connect to the database. It will be created if it doesn't exist.
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Step 1: Create the schema_migrations table if it doesn't exist.
        # This table tracks which migrations have already been applied.
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS schema_migrations (
                version TEXT NOT NULL PRIMARY KEY
            )
        """)
        conn.commit()

        # Step 2: Get the set of already applied migrations.
        cursor.execute("SELECT version FROM schema_migrations")
        applied_migrations = {row[0] for row in cursor.fetchall()}

        # Step 3: Find all migration files in the migrations directory.
        try:
            migration_files = sorted(
                f for f in os.listdir(migrations_dir) if f.endswith('.sql')
            )
        except FileNotFoundError:
            print(f"Error: Migrations directory '{migrations_dir}' not found.")
            return

        # Step 4: Apply any migrations that haven't been applied yet.
        migrations_to_apply = [f for f in migration_files if f not in applied_migrations]

        if not migrations_to_apply:
            print("Database is up to date.")
            return

        for migration_file in migrations_to_apply:
            print(f"Applying migration: {migration_file}...")
            try:
                # Read the migration file content
                filepath = os.path.join(migrations_dir, migration_file)
                with open(filepath, 'r') as f:
                    sql_script = f.read()

                # Execute the SQL script. executescript can handle multiple statements.
                cursor.executescript(sql_script)

                # Record the migration as applied in the same transaction
                cursor.execute(
                    "INSERT INTO schema_migrations (version) VALUES (?)",
                    (migration_file,)
                )
                
                # Commit the transaction for the current migration
                conn.commit()
                print(f"Successfully applied {migration_file}")

            except sqlite3.Error as e:
                print(f"Error applying migration {migration_file}: {e}")
                conn.rollback()  # Rollback changes if a migration fails
                return # Stop processing further migrations

        print("All new migrations applied successfully.")

    except sqlite3.Error as e:
        print(f"A database error occurred: {e}")
    finally:
        if conn:
            conn.close()


class TestDatabaseMigrationsIntegration(unittest.TestCase):

    def setUp(self):
        """Set up a temporary directory for the database and migrations."""
        self.temp_dir_obj = tempfile.TemporaryDirectory()
        self.temp_dir = self.temp_dir_obj.name
        self.db_path = os.path.join(self.temp_dir, 'test.db')
        self.migrations_dir = os.path.join(self.temp_dir, 'migrations')
        os.makedirs(self.migrations_dir)

    def tearDown(self):
        """Clean up the temporary directory."""
        self.temp_dir_obj.cleanup()

    def _create_migration_file(self, filename, content):
        """Helper to create a migration file in the temp migrations directory."""
        with open(os.path.join(self.migrations_dir, filename), 'w') as f:
            f.write(content)

    def _get_db_connection(self):
        """Helper to get a connection to the test database."""
        return sqlite3.connect(self.db_path)

    def _get_applied_migrations(self):
        """Helper to query the schema_migrations table."""
        conn = self._get_db_connection()
        try:
            cursor = conn.cursor()
            cursor.execute("SELECT version FROM schema_migrations ORDER BY version")
            return {row[0] for row in cursor.fetchall()}
        except sqlite3.OperationalError:
            return set()
        finally:
            conn.close()

    def _get_tables(self):
        """Helper to get all table names from the database."""
        conn = self._get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = {row[0] for row in cursor.fetchall()}
        conn.close()
        return tables

    def test_initial_migration_on_new_db(self):
        """
        Tests running migrations on a completely new database.
        It should create the db, schema_migrations table, and apply all migrations.
        """
        self._create_migration_file(
            '001_create_users_table.sql',
            'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);'
        )
        self._create_migration_file(
            '002_create_products_table.sql',
            'CREATE TABLE products (id INTEGER PRIMARY KEY, description TEXT);'
        )

        run_migrations(self.db_path, self.migrations_dir)

        # Check that the database file was created
        self.assertTrue(os.path.exists(self.db_path))

        # Check that the tables were created
        tables = self._get_tables()
        self.assertIn('users', tables)
        self.assertIn('products', tables)
        self.assertIn('schema_migrations', tables)

        # Check that the migrations were recorded
        applied = self._get_applied_migrations()
        self.assertEqual(applied, {
            '001_create_users_table.sql',
            '002_create_products_table.sql'
        })

    def test_applying_new_migrations_to_existing_db(self):
        """
        Tests applying a new migration to a database that is partially migrated.
        """
        # First run with one migration
        self._create_migration_file(
            '001_create_users_table.sql',
            'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);'
        )
        run_migrations(self.db_path, self.migrations_dir)

        # Verify initial state
        self.assertIn('users', self._get_tables())
        self.assertEqual(self._get_applied_migrations(), {'001_create_users_table.sql'})

        # Add a new migration and run again
        self._create_migration_file(
            '002_create_products_table.sql',
            'CREATE TABLE products (id INTEGER PRIMARY KEY, description TEXT);'
        )
        
        f = io.StringIO()
        with contextlib.redirect_stdout(f):
            run_migrations(self.db_path, self.migrations_dir)
        output = f.getvalue()

        # Check that only the new migration was applied
        self.assertIn("Applying migration: 002_create_products_table.sql...", output)
        self.assertNotIn("Applying migration: 001_create_users_table.sql...", output)

        # Verify final state
        self.assertIn('products', self._get_tables())
        self.assertEqual(self._get_applied_migrations(), {
            '001_create_users_table.sql',
            '002_create_products_table.sql'
        })

    def test_no_new_migrations_to_apply(self):
        """
        Tests running the function when the database is already up to date.
        """
        self._create_migration_file(
            '001_create_users_table.sql',
            'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);'
        )
        run_migrations(self.db_path, self.migrations_dir)
        initial_applied = self._get_applied_migrations()

        # Run again with no new migrations
        f = io.StringIO()
        with contextlib.redirect_stdout(f):
            run_migrations(self.db_path, self.migrations_dir)
        output = f.getvalue()

        # Check for "up to date" message
        self.assertIn("Database is up to date.", output)

        # Check that no new migrations were recorded
        self.assertEqual(initial_applied, self._get_applied_migrations())

    def test_migration_failure_and_rollback(self):
        """
        Tests that a failing migration is rolled back and stops subsequent migrations.
        """
        self._create_migration_file(
            '001_create_users_table.sql',
            'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);'
        )
        self._create_migration_file(
            '002_invalid_syntax.sql',
            'CREATE TABL products (id INTEGER PRIMARY KEY);' # Intentional syntax error
        )
        self._create_migration_file(
            '003_create_orders_table.sql',
            'CREATE TABLE orders (id INTEGER PRIMARY KEY);'
        )
        
        f = io.StringIO()
        with contextlib.redirect_stdout(f):
            run_migrations(self.db_path, self.migrations_dir)
        output = f.getvalue()

        # Check for error message
        self.assertIn("Error applying migration 002_invalid_syntax.sql", output)

        # Check that the successful migration was committed
        self.assertIn('users', self._get_tables())
        self.assertIn('001_create_users_table.sql', self._get_applied_migrations())
        
        # Check that the failed migration was rolled back (no products table)
        self.assertNotIn('products', self._get_tables())

        # Check that the failed migration was not recorded
        self.assertNotIn('002_invalid_syntax.sql', self._get_applied_migrations())
        
        # Check that the subsequent migration was not run
        self.assertNotIn('orders', self._get_tables())
        self.assertNotIn('003_create_orders_table.sql', self._get_applied_migrations())
        
    def test_migrations_applied_in_alphabetical_order(self):
        """
        Tests that migrations are sorted and applied in the correct order.
        Here, the second migration depends on the first one.
        """
        # Create migrations in a non-alphabetical order on disk (conceptually)
        self._create_migration_file(
            '002_create_posts_table.sql',
            """
            CREATE TABLE posts (
                id INTEGER PRIMARY KEY,
                content TEXT,
                user_id INTEGER,
                FOREIGN KEY(user_id) REFERENCES users(id)
            );
            """
        )
        self._create_migration_file(
            '001_create_users_table.sql',
            'CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);'
        )
        
        # This will fail if 002 is run before 001 due to the foreign key
        run_migrations(self.db_path, self.migrations_dir)

        # Check that both migrations were applied successfully
        applied = self._get_applied_migrations()
        self.assertEqual(applied, {
            '001_create_users_table.sql',
            '002_create_posts_table.sql'
        })
        tables = self._get_tables()
        self.assertIn('users', tables)
        self.assertIn('posts', tables)

    def test_nonexistent_migrations_directory(self):
        """
        Tests behavior when the provided migrations directory does not exist.
        """
        non_existent_dir = os.path.join(self.temp_dir, 'nonexistent')
        
        f = io.StringIO()
        with contextlib.redirect_stdout(f):
            run_migrations(self.db_path, non_existent_dir)
        output = f.getvalue()

        # Check that the correct error message is printed
        self.assertIn(f"Error: Migrations directory '{non_existent_dir}' not found.", output)
        
        # Check that the DB was created but only contains the migrations table
        self.assertTrue(os.path.exists(self.db_path))
        self.assertEqual(self._get_tables(), {'schema_migrations'})

    def test_empty_migrations_directory(self):
        """
        Tests behavior with an empty migrations directory.
        """
        # setUp creates an empty migrations directory, so we just run the function
        f = io.StringIO()
        with contextlib.redirect_stdout(f):
            run_migrations(self.db_path, self.migrations_dir)
        output = f.getvalue()

        # Should report that the database is up to date
        self.assertIn("Database is up to date.", output)
        
        # The DB should exist with only the schema_migrations table
        self.assertTrue(os.path.exists(self.db_path))
        self.assertEqual(self._get_tables(), {'schema_migrations'})
        self.assertEqual(self._get_applied_migrations(), set())

if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False)

==================================================
